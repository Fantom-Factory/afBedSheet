Overview [#overview]
********************
BedSheet is a [Fantom]`http://fantom.org/` framework for delivering web applications. Built on top of
[afIoc]`http://repo.status302.com/doc/afIoc/#overview` and [Wisp]`http://fantom.org/doc/wisp/index.html`,
BedSheet aims to be: Powerful, Flexible and Simple.

BedSheet is inspired by Java's [Tapestry5]`http://tapestry.apache.org/`, Ruby's [Sinatra]`http://www.sinatrarb.com/` and
Fantom's [Draft]`https://bitbucket.org/afrankvt/draft`.

Quick Start [#quickStart]
*************************

1. Create an 'AppModule', this is where all your service configuration will go.
2. Contribute to 'Routes' and other services
3. Create some page / request handlers
4. Start the app...

pre>
using afBedSheet
using afIoc

class AppModule {
  @Contribute
  static Void contributeRoutes(OrderedConfig conf) {
    conf.add(Route(`/hello/**`, HelloPage#hello))
  }
}

class HelloPage {
  TextResponse hello(Str name, Int iq := 666) {
    return TextResponse.fromPlain("Hello! I'm $name and I have an IQ of $iq!")
  }
}
<pre

From the command line:

pre>
$ fan afBedSheet <mypod>::AppModule 8080
...
BedSheet v1.0 started up in 323ms

$ curl http://localhost:8080/hello/Traci/69
Hello! I'm Traci and I have an IQ of 69!

$ curl http://localhost:8080/hello/Luci
Hello! I'm Luci and I have an IQ of 666!
<pre

Wow! That's awesome! But what just happened!?

Every application has an 'AppModule' that is used to contribute to [afIoc]`http://repo.status302.com/doc/afIoc/#overview`
services. In our 'AppModule' we told the `Routes` service to route all request uris, that start with '/hello', to our
'HelloPage' class. `Route` converts any extra uri path segments into method arguments, or in our case, a 'Str name' and an
optional 'Int iq'.

Request handlers are typically what we, the app developers, write. They perform logic processing and render responses. Our
'HelloPage' handler simply renders a `TextResponse`.

A default `ResponseProcessor` then sends our `TextResponse` to the client.



Starting BedSheet [#startingBedSheet]
*************************************
BedSheet may be started from the command line using:

pre>
$ fan afBedSheet <fully-qualified-app-module-name> <port-number>
<pre

Every BedSheet web application has an 'AppModule' class that defines and configures your
[afIoc]`http://repo.status302.com/doc/afIoc/#overview` services. It is an afIoC concept that allows you centralise your app
configuration in one place.

> TIP: Should your AppModule grow too big, break logical chunks out into their own classes using the afIoc @SubModule facet.

You may find it more convenient to create your own BedSheet Main wrapper. (In fact, if using
[Heroku]`https://bitbucket.org/SlimerDude/heroku-buildpack-fantom` you have to.)

pre>
using util

class Main : AbstractMain {

  @Arg { help="The HTTP port to run the app on" }
  private Int port

  override Int run() {
    afBedSheet::Main().main("<fully-qualified-app-module-name> $port".split)
    return 0
  }
}
<pre

'<fully-qualified-app-module-name>' may be replaced with '<pod-name>' as long as your pod's 'build.fan' defines the following
meta:

pre>
meta  = [ ...
          ...
          "afIoc.module"  : "<fully-qualified-app-module-name>"
        ]
<pre

Note that 'AppModule' is named so out of convention but may be called anything you like.



Request Routing [#requestRouting]
*********************************
When BedSheet receives a web request, it is matched to a handler for processing. This is configured through the `Routes` service.

pre>
@Contribute { serviceType=Routes# }
static Void contributeRoutes(OrderedConfig conf) {

  conf.add(Route(`/index`, IndexPage#service))
}
<pre

BedSheet is bundled with the following Route objs:
 - `Route`: Matches against the request URI, converting deeper path segments into method arguments.

If the handler returns 'Void' or 'null' then processing is passed onto the next matching route. This makes it possible to
create filter like handlers that pre-process a blanket wide set of uris. To do this, contribute a placeholder that all routes
(ordered or unordered) naturally come after. Example:

pre>
@Contribute { serviceType=Routes# }
static Void contributeRoutes(OrderedConfig conf) {

  conf.addPlaceholder("routes")

  // routes
  conf.add(Route(`/index`, IndexPage#service))
  ...

  // filters - addOrdered to ensure they come before routes
  conf.addOrdered("AuthFilter", Route(`/admin/***`, AuthFilter#service), ["before: routes"])
}
<pre

Routes are not limited to matching against uris, you can create your own routes that match against anything, such as http
headers or the time of day! Just create a `RouteMatcher` and contribute it to `RouteMatchers`.

Routing lesson over.

(...you Aussies may stop giggling now.)



Request Handling [#requestHandling]
***********************************
Request handlers are where logic is processed and responses are rendered. Handlers generally shouldn't pipe anything to
'Response.out'. Instead they should return a response object. Example: The above 'HelloPage' handler returns a
`TextResponse`.

BedSheet bundles with the following request handlers:
 - `FileHandler`: Maps request URIs to files on file system.

By default, BedSheet handles the following handler responses:
 - 'Void' / 'null' / 'false' : Processing should fall through to the next Route match.
 - 'true' : A response has been sent to the client and no further processing should performed on the http request.
 - `File` : The file (on the file system) is sent to the client.
 - `TextResponse` : The text (be it plain, json or xml), with the given `MimeType` is sent to the client.



Response Processing [#responseProcessing]
*************************************
[ResponseProcessors]`ResponseProcessor` process request handler responses (`File`, `TextResponse`, etc...) and send data to
the client. 'ResponseProcessors' should return 'true' if no further processing should performed on the http request. Or they
may return another response object for further processing, such as a `TextResponse`.

BedSheet bundles with the following response processors:
 - 'TextResponseProcessor' for sending text to the client
 - 'FileResponseProcessor' for sending files (on the file system) to the client



Error Processing [#errorProcessing]
***********************************
TODO: doc 404, 500 pages and Err handling



BedSheet Dev Proxy
******************
Never (manually) restart your app again! Use the Dev Proxy to auto re-start your app when your pod changes:

pre>
$ fan afBedSheet -proxy <mypod> 8080
<pre

(Goes a step further than Draft 1.0.2 as) The real app dies if the proxy dies! No more lingering Fantom / Java processes.

TODO: docApp Proxy Restarter



Gzip [#gzip]
************
By default, BedSheet compresses HTTP responses where it can.(1) But it doesn't do this willy nilly, oh no! There are many
hurdles to overcome...

Disable All [#disablePerWebApp]
-------------------------------
Gzip, although enabled by default, can be disabled for the entire web app by setting the following config property:

    config.addOverride(ConfigIds.gzipDisabled, "my.gzip.disabled", true)

Disable per Response [#disablePerResponse]
------------------------------------------
Although enabled by default, gzip can be disabled on a per request / response basis by calling the following:

    response.disableGzip()

Gzip'able Mime Types [#mimeTypes]
---------------------------------
Not everything should be gzipped. For example, text files gzip very well and yield high compression rates. JPG images on the
other hand, because they're already compressed, don't gzip well and can end up bigger than the original! For this reason you
must contribute to the `GzipCompressible` service to enable gzip for specified [Mime Types]`sys::MimeType`:

    config["text/funky"] = true

(Note: The GzipCompressible contrib type is actually `MimeType` - afIoc kindly coerces the Str to 'MimeType' for us.)

By default BedSheet will compress plain text, css, html, javascript, xml, json and other text responses.

Gzip only when asked [#askNicely]
---------------------------------
It's guaranteed that someone, somewhere is still using Internet Explorer 3.0 and they can't handle gzipped content. As such,
and as per [RFC 2616 HTTP1.1 Sec14.3]`http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.3`, we only gzip the
response if the client actually *asked* for it!

Minimum content threshold [#minThreshold]
-----------------------------------------
Gzip is great when compressing large files, but if you've only got a few bytes to squash... then the compressed version is
going to be bigger! Which kinda defeats the point of using gzip in the first place! For that reason the response data must
reach a minimum size / threshold before it gets gzipped. Set the threshold config with the following `ApplicationDefaults`:

    config[ConfigIds.gzipThreshold] = 768

See `GzipOutStream` and `ConfigIds.gzipThreshold` for more details.

Phew! Made it! [#madeIt]
------------------------
If (and only if!) your data passed all the tests above, then it will be lovingly gzipped and sent to the client.

 - (1) `http://betterexplained.com/articles/how-to-optimize-your-site-with-gzip-compression/`



Buffered Response
*****************
By default, BedSheet attempts to set the 'Content-Length' http header in the http response.(2) It does this by buffering
'HttpResponse.out'. When the stream is closed, it writes the 'Content-Length' and pipes the buffer to the real http response.

A threshold can be set, whereby if the buffer exeeds that value, all content is streamed direct to the client.

See `BufferedOutStream` and `ConfigIds.responseBufferThreshold` for more details.

 - (2) `http://stackoverflow.com/questions/2419281/content-length-header-versus-chunked-encoding`



More!
*****
All request handlers and processors are built by [afIoc]`http://repo.status302.com/doc/afIoc/#overview` so feel free to '@Inject'
DAOs and other services. BedSheet itself is built with [afIoc]`http://repo.status302.com/doc/afIoc/#overview` so look at the
[BedSheet source]`XXX` for afIoc examples.

> TIP: 'const' handler classes are cached by BedSheet and reused on every request.

There's also some Err reporting, HTTP status handling and more besides. It's early days still...

TODO: doc Internet Explorer Ajax Cache Buster

TODO: doc CORS



Push To Live! [#goLive]
***********************
In a hurry to go live?

Check out [Heroku]`http://www.heroku.com/` and see how ridiculously easy it is to deploy your app to a live server with the
[heroku-fantom-buildpack]`https://bitbucket.org/SlimerDude/heroku-buildpack-fantom`.



Release Notes [#releaseNotes]
*****************************

Breaking Changes
================

v0.0.6 [#v0.0.6]
----------------
 - `Route` URIs now need the suffix '**' to match all remaiing method arguments
 - 'TextResult' has been renamed to 'TextRepsonse'
 - 'MoustacheSource' has been renamed to 'MoustacheTemplates'
 - All Services ending in 'Source' have renamed to their plural. Example: ValueEncoderSource -> ValueEncoders

