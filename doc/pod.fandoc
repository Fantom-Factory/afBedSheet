Overview [#overview]
********************
BedSheet is a [Fantom]`http://fantom.org/` framework for delivering web applications. Built on top of
[afIoc]`http://repo.status302.com/doc/afIoc/#overview` and [Wisp]`http://fantom.org/doc/wisp/index.html`, BedSheet aims to be:

Powerful.
---------
Built in a modular way with [afIoc]`http://repo.status302.com/doc/afIoc/#overview` meaning every service maybe wrapped,
decorated, replaced or deleted! It makes hard tasks, easy.

Flexible.
---------
Show a developer a really cool feature and the first response is usually, "Wow, that's awewome! ... But how do I turn it off?"
With that in mind, BedSheet is reluctant

Simple.
-------
Developers are lazy. If it's complicated or difficult, they won't use it.

BedSheet is inspired by Java's [Tapestry5]`http://tapestry.apache.org/`, Ruby's [Sinatra]`http://www.sinatrarb.com/` and Fantom's [Draft]`https://bitbucket.org/afrankvt/draft`.

Quick Start [#quickStart]
*************************

1. Create an 'AppModule', this is where all your service configuration will go.
2. Contribute to 'Routes' and other services
3. Create some page / request handlers
4. Start the app...

pre>
using afBedSheet
using afIoc

class AppModule {
  @Contribute
  static Void contributeRoutes(OrderedConfig conf) {
    conf.add(ArgRoute(`/hello`, HelloPage#hello))
  }
}

class HelloPage {
  TextResult hello(Str name, Int iq := 666) {
    return TextResult.fromPlain("Hello! I'm $name and I have an IQ of $iq!")
  }
}
<pre

From the command line:

pre>
$ fan afBedSheet <mypod>::AppModule 8080
...
BedSheet v1.0 started up in 323ms

$ curl http://localhost:8080/hello/Traci/69
Hello! I'm Traci and I have an IQ of 69!

$ curl http://localhost:8080/hello/Luci
Hello! I'm Luci and I have an IQ of 666!
<pre

Wow! That's awesome! But what just happened!?

Every application has an 'AppModule' that is used to contribute to [afIoc]`http://repo.status302.com/doc/afIoc/#overview`
services. In our 'AppModule' we told the `Routes` service to route all request uris, that start with '/hello', to our
'HelloPage' class. `ArgRoute` converts any extra uri path segments into method arguments, or in our case, a 'Str name' and an
optional 'Int iq'.

Request handlers are typically what we, the app developers, write. They perform logic processing and render responses. Our
'HelloPage' handler simply renders a `TextResponse`.

A default `ResultProcessor` then sends our `TextResponse` to the client.



Starting BedSheet [#startingBedSheet]
*************************************
BedSheet may be started from the command line using:

pre>
$ fan afBedSheet <fully-qualified-app-module-name> <port-number>
<pre

Every BedSheet web application has an 'AppModule' class that defines and configures your
[afIoc]`http://repo.status302.com/doc/afIoc/#overview` services. It is an afIoC concept that allows you centralise your app
configuration in one place.

> TIP: Should your AppModule grow too big, break logical chunks out into their own classes using the afIoc @SubModule facet.

You may find it more convenient to create your own BedSheet Main wrapper. (In fact, if using
[Heroku]`https://bitbucket.org/SlimerDude/heroku-buildpack-fantom` you have to.)

pre>
using util

class Main : AbstractMain {

  @Arg { help="The HTTP port to run the app on" }
  private Int port

  override Int run() {
    afBedSheet::Main().main("<fully-qualified-app-module-name> $port".split)
    return 0
  }
}
<pre

'<fully-qualified-app-module-name>' may be replaced with '<pod-name>' as long as your pod's 'build.fan' defines the following
meta:

pre>
meta  = [ ...
          "afIoc.module"  : "<fully-qualified-app-module-name>"
          ...
        ]
<pre

Note that 'AppModule' is named so out of convention but may be called anything you like.



Request Routing [#requestRouting]
*********************************
When BedSheet receives a web request, it is matched to a handler for processing. This is configured through the `Routes` service.

pre>
@Contribute { serviceType=Routes# }
static Void contributeRoutes(OrderedConfig conf) {

  conf.add(ArgRoute(`/index`, IndexPage#service))

}
<pre

BedSheet is bundled with the following Routes objs:
 - `ArgRoute`: Matches against the request URI, converting deeper path segments into method arguments.

If the handler returns 'Void' or 'null' then processing is passed onto the next matching route. This makes it possible to
create filter like handlers that blanket pre-process a wide set of uris. To facilitate this, BedSheet contributes a placeholder
called "Routes" that all routes (ordered or unordered) naturally come after. Example:

pre>
@Contribute { serviceType=Routes# }
static Void contributeRoutes(OrderedConfig conf) {

  // add filter to check all requests under `/admin` are authorised
  conf.addOrdered("AuthFilter", ArgRoute(`/admin`, AuthFilter#service), ["before: Routes"])
}
<pre

Routes are not limited to matching against uris, you can create your own routes that match against anything, such as http
headers or the time of day! Just create a `RouteMatcher` and contribute it to `RouteMatcherSource`.

Routing lesson over.

(...you Aussies may stop giggling now.)



Request Handling [#requestHandling]
***********************************

TODO: return values

BedSheet is bundled with the following request handlers:
 - `FileHandler`: Maps request URIs to Files on file system.



Result Processing [#resultProcessing]
*************************************
It's the job of [ResultProcessors]`ResultProcessor` to send a responses to the client.

'ResultProcessors' deal with the results returned

Instead handlers return objects that 'ResultProcessors' deal with. Current default handlers include 'TextResult' and 'JsonResult'.

If the response is over a given size, and is deemed compressible then it is gzipped before being sent to the user.

By default, BedSheet processes the following handler responses:
 - `File`
 - `TextResponse`


Error Processing [#errorProcessing]
***********************************
TODO: 404 & 500

TODO: App Proxy Restarter

TODO:
TODO: Out Buffer

TODO: Misc
 - Internet Explorer Ajax Cache Buster
 - CORS


Gzip [#gzip]
************
By default, BedSheet compresses HTTP responses where it can.(1) But it doesn't do this willy nilly, oh no! There are many
hurdles to overcome...

Disable All [#disablePerWebApp]
-------------------------------
Gzip, although enabled by default, can be disabled for the entire web app by setting the following config property:

    config.addOverride(ConfigIds.gzipDisabled, "my.gzip.disabled", true)

Disable per Response [#disablePerResponse]
------------------------------------------
Although enabled by default, gzip can be disabled on a per request / response basis by calling the following:

    response.disableGzip()

Gzip'able Mime Types [#mimeTypes]
---------------------------------
Not everything should be gzipped. For example, text files gzip very well and yield high compression rates. JPG images on the other hand, because they're already compressed, don't gzip well and can end up bigger than the original! For this reason you must contribute to the `GzipCompressible` service to enable gzip for specified [Mime Types]`sys::MimeType`:

    config[MimeType("text/funky")] = true

By default BedSheet will compress plain text, css, html, javascript, xml and json responses.

Gzip only when asked [#askNicely]
---------------------------------
It's guaranteed that someone, somewhere is still using Internet Explorer 3.0 and they can't handle gzipped content. As such, and as per [RFC 2616 HTTP1.1 Sec14.3]`http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.3`, we only gzip the response if the client actually *asked* for it!

Minimum content threshold [#minThreshold]
-----------------------------------------
Gzip is great when compressing large files, but if you've only got a few bytes to squash... then the compressed version is going to be bigger! Which kinda defeats the point of using gzip in the first place! For that reason the response data must reach a minimum size / threshold before it gets gzipped. Set the threshold config with the following `ApplicationDefaults`:

    config[ConfigIds.gzipThreshold] = 768

See `GzipOutStream` and `ConfigIds.gzipThreshold` for more details.

Phew! Made it! [#madeIt]
------------------------
If (and only if!) your data passed all the tests above, then it will be lovingly gzipped and sent to the client.

 - (1) `http://betterexplained.com/articles/how-to-optimize-your-site-with-gzip-compression/`

Buffered Response
*****************

 - (2) `http://stackoverflow.com/questions/2419281/content-length-header-versus-chunked-encoding`


More!
=====
All URI handlers and processors are built by [afIoc]`http://repo.status302.com/doc/afIoc/#overview` so feel free to '@Inject' DAOs and other services. BedSheet itself is built with [afIoc]`http://repo.status302.com/doc/afIoc/#overview` so look at the [BedSheet source]`XXX` for afIoc examples.

> TIP: 'const' handler classes are cached by BedSheet and reused on every request.

There's also some Err reporting, HTTP status handling and probably more besides. It's early days still...



Push To Live! [#goLive]
***********************
In a hurry to go live?

Check out [Heroku]`http://www.heroku.com/` and see how ridiculously easy it is to deploy your app to a live server with the [heroku-fantom-buildpack]`https://bitbucket.org/SlimerDude/heroku-buildpack-fantom`.


Release Notes [#releaseNotes]
*****************************

v0.0.6 [#v0.0.6]
----------------
 - New: CORS
 - Chg: Routing overhaul.

v0.0.4 [#v0.0.4]
----------------
 - New: Proxy mode to restart web app on pod change.
 - Chg: Gzip handling overhauled.
 - Chg: afIoc upgraded to 1.3.2.
 - Bug: Resolved issue injecting Request & Response into handler classes.

v0.0.2 [#v0.0.2]
----------------
 - Preview release.


